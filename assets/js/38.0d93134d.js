(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{538:function(v,_,t){v.exports=t.p+"assets/img/image-20210314141302793.58ea9221.png"},627:function(v,_,t){"use strict";t.r(_);var s=t(6),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("p",[v._v("TCP 在运输连接时有三个阶段，即连接建立、数据传输和连接释放")]),v._v(" "),s("h2",{attrs:{id:"tcp-三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手"}},[v._v("#")]),v._v(" TCP 三次握手")]),v._v(" "),s("p",[v._v("在 TCP 传输数据之前需要先建立连接，而建立连接就需要进行三次握手。")]),v._v(" "),s("p",[v._v("三次握手的主要目的是确认双方都有"),s("strong",[v._v("发送的能力")]),v._v("和"),s("strong",[v._v("接收的能力")]),v._v("，建立点对点的连接通道，具体的握手过程图如下：")]),v._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:t(538),alt:"image-20210314141302793"}}),v._v(" "),s("ul",[s("li",[v._v("在建立连接开始之前，双方都处于 CLOSED 状态。然后 B 服务器开始监听某个端口，进入 LISTEN 状态")]),v._v(" "),s("li",[v._v("A 发送方主动建立连接，向 B 发出连接请求报文段，这时首部中 SYN=1 以及选择一个初始序号 seq=x。此时客户 A 进程进入 SYN-SENT（同步已发送）状态")]),v._v(" "),s("li",[v._v("B 接收方收到报文段后，向 A 发送确认报文段，报文段中 SYN 和 ACK 都置1，确认序号 ack=x+1，同时为自己选择一个初始序号 seq=y。此时服务器 B 进程进入 SYN-RCVD（同步收到）状态")]),v._v(" "),s("li",[v._v("A 接收确认报文段后，也要向 B 发送确认。其中 ACK 置1，确认序号 ack=y+1，自己的序号 seq=x+1。此时客户 A 进入 ESTABLISHED（已建立连接）状态")]),v._v(" "),s("li",[v._v("当 B 收到 A 的确认后，也进入 ESTABLISHED（已建立连接）状态。")])]),v._v(" "),s("h2",{attrs:{id:"为什么不是两次"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是两次"}},[v._v("#")]),v._v(" 为什么不是两次？")]),v._v(" "),s("p",[v._v("因为两次握手无法确认客户端的接收能力，三次握手能防止已失效连接请求报文突然又传送到接收方造成接收方资源浪费。")]),v._v(" "),s("p",[v._v("假设 A 发出第一个连接请求报文段因某些原因长时间滞留而迟迟未收到 B 的确认，于是 A 重新再发一次连接请求。后来收到确认，建立了连接。数据传输完毕后就释放了连接。但第一个连接请求此时才到达 B，这时 B 会误认为 A 又发起了新的连接，于是向 A 发出确认，同意连接。")]),v._v(" "),s("p",[v._v("假设只采用两次握手，那么在上面这种情况下 A 与正常连接一样不会向 B 发送确认，所以 B 会一直处于建立连接状态，一直等待 A 发送数据过来，白白浪费资源。")]),v._v(" "),s("p",[v._v("因此需要采用三次握手的办法来防止上面情况的发生。")]),v._v(" "),s("h2",{attrs:{id:"为什么不是四次"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是四次"}},[v._v("#")]),v._v(" 为什么不是四次？")]),v._v(" "),s("p",[v._v("可以但没必要。")]),v._v(" "),s("p",[v._v("三次握手的目的是确认双方都有"),s("strong",[v._v("发送的能力")]),v._v("和"),s("strong",[v._v("接收的能力")]),v._v("。既然三次握手便能够确认，那为什么要四次呢，这不白白浪费网络资源吗，还延长了请求的时间。")]),v._v(" "),s("h2",{attrs:{id:"安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全"}},[v._v("#")]),v._v(" 安全")]),v._v(" "),s("p",[v._v("三次握手中的前两次握手是不能携带数据的，究其原因是为了保障安全。")]),v._v(" "),s("p",[v._v("如果前两次握手能够携带数据，那么一旦有人想攻击服务器，他只需要在第一次握手的请求连接报文中放置大量数据，那么服务器将消耗大量的时间和资源去处理这些数据，造成服务器的繁忙。")]),v._v(" "),s("p",[v._v("但除了上面的操作之外，攻击者 A 还有可能向服务器发出一个 SYN 报文，当服务器返回 ACK 之后，A 不再进行确认，那么此时这个连接就处在一个挂起的状态 SYN-SENT。服务器收不到确认的消息，还会重复发送 ACK 给 A，这样一来就会浪费服务器的资源。若 A 发送大量的这种 TCP 连接且持续不断，由于每个连接都没有完成握手的机会，长时间下来就会消耗服务器的内存最后可能会导致无法正常工作。这种攻击手法就是著名的"),s("strong",[v._v("SYN 洪泛攻击")]),v._v("。")]),v._v(" "),s("p",[v._v("那么如何去防范这种 SYN 攻击呢？")]),v._v(" "),s("ul",[s("li",[v._v("优化主机系统设置，降低 SYN timeout 时间，使得主机尽快释放半连接")]),v._v(" "),s("li",[v._v("对 IP 地址进行判断，若短时间内收到某个 IP 的重复 SYN 请求，那么就认为受到攻击")]),v._v(" "),s("li",[v._v("采用防火墙设置等外部网络对其拦截")])])])}),[],!1,null,null,null);_.default=a.exports}}]);