(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{541:function(v,_,t){v.exports=t.p+"assets/img/image-20210322200852742.f2d45ac7.png"},542:function(v,_,t){v.exports=t.p+"assets/img/image-20210322202344889.735cda17.png"},543:function(v,_,t){v.exports=t.p+"assets/img/image-20210322204743963.e6ee57e3.png"},629:function(v,_,t){"use strict";t.r(_);var s=t(6),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("p",[v._v("我们知道，TCP 是可靠的传输层协议，然而 TCP 发送的报文段是交给 IP 层传送的。但 IP 层只能提供尽最大努力交付，也就是说 TCP 下面的网络提供的是不可靠的传输。因此 TCP 需要采用适当的措施才能使两个运输层之间的通信变得可靠。")]),v._v(" "),s("p",[v._v("由于传输信道是不可能永远没有差错的，所以 TCP 可靠传输的实现有以下几个特点")]),v._v(" "),s("ul",[s("li",[v._v("当出现差错时，让发送方重传出现差错的数据")]),v._v(" "),s("li",[v._v("当接收方来不及处理收到的数据时，及时告知发送方适当降低发送数据的速度")])]),v._v(" "),s("h2",{attrs:{id:"可靠传输的基本原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可靠传输的基本原理"}},[v._v("#")]),v._v(" 可靠传输的基本原理")]),v._v(" "),s("h3",{attrs:{id:"停止等待协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#停止等待协议"}},[v._v("#")]),v._v(" 停止等待协议")]),v._v(" "),s("p",[v._v("停止等待协议很容易理解，发送方发送消息后等待接收方确认后再发送下一个报文，接收方亦是如此。")]),v._v(" "),s("p",[v._v("而对于传输的数据出现差错的情况，TCP 在每发送一个报文后就会设置"),s("strong",[v._v("超时计时器")]),v._v("，如果超时计时器到期之前收到对方的确认就撤销已设置的超时计时器。若超时计时器到期都没有收到确认便会重新发送数据，这就是"),s("strong",[v._v("超时重传")]),v._v("。")]),v._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:t(541),alt:"image-20210322200852742"}}),v._v(" "),s("p",[v._v("传输的数据出现差错的情况会很多，例如发送的数据在路上丢失了、确认的数据在路上丢失了、确认的数据因某种原因搁置了，经过很长的时间才到，不过这些情况都可以利用超时重传解决。")]),v._v(" "),s("h3",{attrs:{id:"连续-arq-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#连续-arq-协议"}},[v._v("#")]),v._v(" 连续 ARQ 协议")]),v._v(" "),s("p",[v._v("停止等待协议有一个很严重的问题，那就是信道利用率太低。所以为了提高传输效率，发送方不采用停止等待协议，而是采用流水线传输。流水线传输的一种实现就是"),s("strong",[v._v("连续 ARQ 协议")]),v._v("。")]),v._v(" "),s("ul",[s("li",[v._v("发送方会维持一个"),s("strong",[v._v("发送窗口 rwnd")]),v._v("，位于发送窗口内的数据都可以连续发送出去，无需等待对方确认。")]),v._v(" "),s("li",[v._v("发送方每收到一个确认，就把发送窗口向前滑动一个位置，接着便可以发送下一个了")]),v._v(" "),s("li",[v._v("接收方采用"),s("strong",[v._v("累计确认")]),v._v("的方式来确认应答，接收方不必对接收到的每个数据进行确认，而是对按序到达的最后一份数据发送确认，表示在这之前的所有数据都正确收到了")]),v._v(" "),s("li",[v._v("接收方会维持一个接收窗口，大小与发送窗口一样，这些窗口都统称为"),s("strong",[v._v("滑动窗口")])])]),v._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:t(542),alt:"image-20210322202344889"}}),v._v(" "),s("p",[v._v("对于发送窗口的大小是由接收方在 TCP 首部的窗口大小字段来设置的")]),v._v(" "),s("h2",{attrs:{id:"可靠传输的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可靠传输的实现"}},[v._v("#")]),v._v(" 可靠传输的实现")]),v._v(" "),s("p",[v._v("TCP 的滑动窗口是以字节为单位的。由于 TCP 是全双工通信，也就是发送方也可以是接收方，这也意味着发送方即有发送窗口也可能有接收窗口，这里我们假定数据传输只在一个方向进行。")]),v._v(" "),s("p",[v._v("要描述一个发送窗口的状态需要三个指针：P1、P2、P3")]),v._v(" "),s("ul",[s("li",[v._v("P3-P1 = 窗口大小")]),v._v(" "),s("li",[v._v("P1 之前为"),s("strong",[v._v("已发送并收到确认")]),v._v("的字节")]),v._v(" "),s("li",[v._v("P1到P2 之间是"),s("strong",[v._v("已发送但未收到确认")]),v._v("的字节")]),v._v(" "),s("li",[v._v("P2到P3 之间是"),s("strong",[v._v("允许发送但尚未发送")]),v._v("的字节")]),v._v(" "),s("li",[v._v("P3 之后是目前还"),s("strong",[v._v("不允许发送")]),v._v("的字节")])]),v._v(" "),s("p",[v._v("而接收窗口分为三部分")]),v._v(" "),s("ul",[s("li",[v._v("已发送确认并交付主机")]),v._v(" "),s("li",[v._v("允许接收（接收窗口的大小）")]),v._v(" "),s("li",[v._v("不允许接收")])]),v._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:t(543),alt:"image-20210322204743963"}}),v._v(" "),s("p",[v._v("例如上面这个例子，A 向 B 发送了从31到41序号的11个字节，但是 B 收到的是32和33序号的字节，然而 B 期望收到的是31序号，说明这两个字节是未按序到达的，此时 B 发送的确认报文段的确认号仍然是31（即期望收到的序号）。")]),v._v(" "),s("p",[v._v("假定 B 收到了序号为31的数据，那么 B 会向 A 发送确认报文段的确认号是34，并将接收窗口向前滑动，A 接收到确认后也会向前滑动。")]),v._v(" "),s("p",[v._v("另外，TCP 的重传机制是选择重传，也就是接收端会将未按序收到的报文会放入缓冲区，并发送期望收到序号的确认包给发送方，等期望收到的包到达后才会进行处理。")])])}),[],!1,null,null,null);_.default=a.exports}}]);