(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{534:function(t,v,_){t.exports=_.p+"assets/img/image-20210322223754454.db5ab76e.png"},624:function(t,v,_){"use strict";_.r(v);var r=_(6),s=Object(r.a)({},(function(){var t=this,v=t.$createElement,r=t._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"流量控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[t._v("#")]),t._v(" 流量控制")]),t._v(" "),r("p",[t._v("当发送方把数据发送得过快的时候，接收方就可能来不及接收，这样就会造成数据的丢失。为防止这种情况的发生，就出现了流量控制。流量控制就是"),r("strong",[t._v("让发送方的发送速率不要太快，要让接收方来得及接收")]),t._v("。")]),t._v(" "),r("p",[t._v("流量控制的实现是利用滑动窗口机制，由接收方设置 TCP 首部的 rwnd 来控制发送方窗口的大小。")]),t._v(" "),r("img",{staticStyle:{zoom:"80%"},attrs:{src:_(534),alt:"image-20210322223754454"}}),t._v(" "),r("p",[t._v("以上面的传输过程为例（TCP 连接建立的窗口协商没有显示出来）。")]),t._v(" "),r("ul",[r("li",[t._v("在 TCP 连接建立时，B 与 A 协商窗口大小 rwnd=400。")]),t._v(" "),r("li",[t._v("A发送了从1到300字节的数据，但201到300字节的数据丢失了，所以B 确认了201（下一个期望收到的序号），并将窗口大小修改为300")]),t._v(" "),r("li",[t._v("接着A发送新数据以及超时重传旧的数据，此时发送窗口已满不能再发送了")]),t._v(" "),r("li",[t._v(".....")])]),t._v(" "),r("p",[t._v("上面的流程中，接收方的主机 B 进行了三次流量控制。第一次 rwnd=100，第二次 rwnd=100，最后将窗口减到 0，即不允许发送方再发送数据了。这种状态将持续到 B 重新发出一个新的窗口值为止。")]),t._v(" "),r("h2",{attrs:{id:"持续计时器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#持续计时器"}},[t._v("#")]),t._v(" 持续计时器")]),t._v(" "),r("p",[t._v("让我们假设一种情况，假如窗口为 0，此时 B 向 A 发送了 rwnd=400 的报文段，然而这个报文段在传送过程中丢失了。此时 A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据，这就产生了相互等待的死锁局面。")]),t._v(" "),r("p",[t._v("为解决上面这个问题，TCP 为每一个连接都设有一个"),r("strong",[t._v("持续计时器")]),t._v("。只要 TCP 连接的一方收到对方的零窗口通知就启动持续计时器，若计时器设置的时间到期就发送一个"),r("strong",[t._v("零窗口探测报文段")]),t._v("，对方便能在确认这个探测报文段时给出现在的窗口值，这样就能打破死锁的局面。")])])}),[],!1,null,null,null);v.default=s.exports}}]);